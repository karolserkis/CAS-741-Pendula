\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{listings}

\lstset{ %
	breaklines = true
}

\externaldocument{../../SRS/SRS}
\newcommand{\rref}[1]{R\ref{#1}}
\newcommand{\ddref}[1]{DD\ref{#1}}

\hypersetup{
	bookmarks=true,     % show bookmarks bar?
	colorlinks=true,       % false: boxed links; true: colored links
	citecolor=ForestGreen,
	filecolor=WildStrawberry,
	linkcolor=Purple,
	urlcolor=Cerulean      % color of external links
}

\usepackage{array}

\input{../../Comments}

\newcommand{\progname}{Companion Cube Calculator}
\newcommand{\prognameAbbrv}{$C^{3}$}

\begin{document}

\title{Module Interface Specification for the \progname{} (\prognameAbbrv{})}

\author{Geneva Smith}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
December 18, 2017 & 2.0 & Updated the document to reflect the current 
implementation \\
December 17, 2017 & 1.2 & Updated the Control Flow and Input specifications to 
match the resulting implementation \\
December 7, 2017 & 1.1.1 & Revised the operator data structure with missing 
``get" operator, a new exception, and seperated the \texttt{numOperands} 
Integer state variable into three Boolean state variables; added terminator 
variables to Solver module\\
December 5, 2017 & 1.1 & Added a specification for an operator data structure \\
November 27, 2017 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at 
\url{https://github.com/GenevaS/CAS741/tree/master/Doc/SRS} for project 
symbols, abbreviations, and acronyms.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}
The following document details the Module Interface Specifications for the 
\progname{} (\prognameAbbrv{}), a mathematical tool which determines the range 
of a user-specified function given the domains of the function's variables. The 
calculations are performed using interval arithmetic.

It is assumed that the chosen implementation language will automatically check 
that the appropriate number of inputs are provided to a function and that all 
inputs are of the expected type. Therefore, these exceptions are not listed in 
this specification.

Complementary documents include the System Requirement Specifications
and Module Guide. The full documentation and implementation can be
found at:
\begin{center}
	\href{https://github.com/GenevaS/CAS741}{https://github.com/GenevaS/CAS741}
\end{center}

\newpage

\section{Notation}
The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
Boolean & $\mathbb{B}$ & The set of $\{True, False\}$\\
Integer & $\mathbb{Z}$ & Any whole number in (-$\infty$, $\infty$)\\
Natural & $\mathbb{N}$ & Any number in $\{0, 1, 2, 3, ...\}$\\
Real & $\mathbb{R}$ & Any number in (-$\infty$, $\infty$)\\
\multirow{2}{1cm}{String} & \multirow{2}{1cm}{$char^n$} & A sequence of 
alphanumeric and special characters\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname{} uses some derived data types: sequences and 
strings. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. In addition, \progname{} uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\newpage

\section{Module Decomposition}
The following table is taken directly from the Module Guide document for this 
project. It can be found at 
\href{https://github.com/GenevaS/CAS741/blob/master/Doc/Design/MG}{https://github.com/GenevaS/CAS741/blob/master/Doc/Design/MG}.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.35\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & - \\
		\midrule
		
		\multirow{7}{0.29\textwidth}{Behaviour-Hiding Module} & Control Flow 
		Module \\
		& User Input Module \\
		& Interval Conversion Module \\
		& Equation Conversion Module \\
		& Variable Consolidation Module \\
		& Range Solver Module \\
		& Output Module \\
		\midrule
		
		\multirow{2}{0.29\textwidth}{Software Decision Module} & Interval Data 
		Structure Module \\
		& Equation Data Structure Module \\
		& Operator Data Structure Module \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

~\newpage

\section{MIS of the Control Flow Module} 
\label{Module_controlflow}
The Control Flow module is the only access point that external applications 
should use when implementing the Companion Cube Calculator. This affords the 
freedom to create any type of user interface without changing any of the 
underlying structure. In some cases, this means that a Control Flow access 
program simply returns the outputs from other module access programs without 
modifying them.

\subsection{Module}

ControlFlow

\subsection{Uses}

Input (Section~\ref{Module_userinput}), Consolidate 
(Section~\ref{Module_variableconsolidation}), Solver 
(Section~\ref{Module_rangesolver}), Output (Section~\ref{Module_output}),
IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.2cm} p{3cm} p{3cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
Initialize & - & $Boolean$ & - \\
ConditionRawInput & $String$, $Boolean$ & $String$ & - \\
ControlFile & $String$ & $String^n$ & - \\
ControlDirect & $String$, $String$ & $String^n$ & - \\
GetSuccessCode & - & $Int$ & - \\
GetValidFileTypes & - & $String^n$ & - \\
GetDelimiters & - & $String^2$ & - \\
ExtractVariables& $String$ & $String^n$ & - \\
GetVariableInfo & - & $String^{n \times 3}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $hasRun$ : $Boolean$
	\item $successCode$ : $Int$
\end{itemize}

\newpage
\subsubsection{Access Routine Semantics}

\noindent Initialize():
\begin{itemize}
	\item output: $out := success$ where $success$ is the output of the 
	Initialize access program from the Variable Consolidation module
	\item exception: N/A
\end{itemize}

\noindent ConditionRawInput($input, preserveSpecialChars$):
\begin{itemize}
	\item output: $out := conditionedLine$ where $conditioned$ is the output of 
	the RemoveWhitespace access program from the Input module
	\item exception: N/A
\end{itemize}

\noindent ControlFile($fileName$):
\begin{itemize}
	\item output: $out := inputs$ where $inputs$ is the output of the 
	ReadFile access program from the Input module
	\item exception: N/A
\end{itemize}

\noindent ControlDirect($equationString, variableListString$):
\begin{itemize}
	\item transition: Updates the $successCode$ state variable with the return 
	value of the ConvertAndCheckInputs access program from the Consolidate 
	module. If the ControlDirect access program completes successfully, update 
	the $hasRun$ state variable to $True$.
	\item output: $out := results$ where:
	\begin{itemize}
		\item The program completed successfully:\\
		$results$ is the sequence $range, equationTree$. The value for $range$ 
		is the output of the PrintInterval access program from the Output 
		module and the value for $equationTree$ is the output of the 
		PrintEquationTree access program from the Output module.
		\item The program was not completed successfully, $results$ is $NULL$
	\end{itemize} 

	\begin{lstlisting}
	results = NULL
	successCode = Consolidate.ConvertAndCheckInputs(equationString, 
	   variableListString, 
	   Solver.GetValidOperators(), 
	   Solver.GetValidTerminators())
	if successCode = 0
	  range = Solver.FindRange(
	     Consolidate.GetEquationStruct(), 
	     Consolidate.GetIntervalStructList())
	  if range != NULL
	    results = {Output.PrintInterval(range), 
	               Output.PrintEquationTree(Consolidate.GetEquationStruct())}
	    hasRun = TRUE
	return results
	\end{lstlisting}
\end{itemize}

\noindent GetSuccessCode():
\begin{itemize}
	\item output: $out := successCode$
	\item exception: N/A
\end{itemize}

\noindent GetValidFileTypes():
\begin{itemize}
	\item output: $out := validFileTypes$ where $validFileTypes$ is the output 
	of the GetValidFileTypes access program from the Input module.
	\item exception: N/A
\end{itemize}

\noindent GetDelimiters():
\begin{itemize}
	\item output: $out := delimiters$ where $delimiters$ is the set of input 
	delimiters. The sequence size is two, where the first value is the output 
	of the GetLineDelimiter access program from the Input module and the second 
	value is the output of the GetFieldDelimiter access program from the Input 
	module. Both values in the sequence contain unescaped character sequences.
	\item exception: N/A
\end{itemize}

\noindent ExtractVariables():
\begin{itemize}
	\item output: $out := varList$ where $varList$ is the output of the 
	ExtractVariablesFromEquation access program from the Consolidate module.
	\item exception: N/A
\end{itemize}

\noindent GetVariableInfo():
\begin{itemize}
	\item output: $out := varInfoList$ where:
	\begin{lstlisting}
	Initialize varInfoList = NULL
	if hasRun is TRUE
	  intervalList = Consolidate.GetIntervalStructList()
	  if the interval list contains data
	    foreach(interval in intervalList)
	      varInfoList.Add(interval.GetVariableName, 
	                      interval.GetMinBound, 
                              interval.GetMaxBound)
    return varInfoList
	\end{lstlisting}
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the User Input Module} 
\label{Module_userinput}
The Input Module is responsible for the File I/O and string formatting 
processes required by the program. This module simply outputs a pair of strings 
(equation and variable information) and leaves the conditioning and validation 
of the actual values to the Variable Consolidation Module 
(Section~\ref{Module_variableconsolidation}). This completely decouples input 
acquisition from files and the internal function of the program, allowing for 
other input methods to be implemented simultaneously while reducing the number 
of modules to modify if the underlying data structures 
(Section~\ref{Module_intervaldatastructure} and 
~\ref{Module_equationdatastructure}) change.

\subsection{Module}

Input

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $lineDelimiter$ : $String$
	\item $fieldDelimiter$ : $String$
	\item $validFileTypes$ : $String^n$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{5}{3.3cm}{ReadFile} & \multirow{5}{3cm}{$String$} & 
		\multirow{5}{3cm}{$String^2$} & IN\_CANNOT\_READ\_FILE, \\
		 &  &  & IN\_EMPTY\_FILE, \\
		 & & & IN\_INVALID\_FILE\_TYPE,\\
		 & & &  IN\_NO\_EQUATION,\\
		 & & & IN\_NO\_FILE\\
		 RemoveWhitespace & $String$, $Bool$ & $String$ & - \\
		 GetLineDelimiter & - & $String$ & - \\
		 GetFieldDelimiter & - & $String$ & - \\
		 GetValidFileTypes & - & $String^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item Input files must be formatted such that:	
	\begin{itemize}
		\item The user equation is on the first line
		\item Each subsequent line contains the information (name, minimum 
		bound, and maximum bound) for variables. Each line contains one 
		variable definition, and each field in the variable definition is 
		separated by the $fieldDelimiter$.
	\end{itemize}
	The end of each line must be the value of $lineDelimiter$.
	\item The conditioning and validation of file contents is performed by the 
	Variable Consolidation module (Section~\ref{Module_variableconsolidation}).
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent ReadFile($fileName$):
\begin{itemize}
	\item output: $out := fileContents$ where:
	\begin{itemize}
		\item $fileContents = \{fileName[0], fileName[1,fileName.Length]$ if no 
		exception was 
		raised
		\item $fileContents = NULL$ if an exception was raised
	\end{itemize}
	\item exception: $exc := \\
	(\neg Read(fileName) \Rightarrow IN\_CANNOT\_READ\_FILE)\\
	|\\
	(Read(fileName) == \emptyset \Rightarrow IN\_EMPTY\_FILE)\\
	|\\
	(fileName.Extension \notin validFileTypes \Rightarrow 
	IN\_INVALID\_FILE\_TYPE)\\
	|\\
	(fileName[0].Exists \wedge fileName[0].Contains(fieldDelimiter) \Rightarrow 
	IN\_NO\_EQUATION)\\
	|\\	
	(\neg fileName.Exists \Rightarrow IN\_NO\_FILE)$
\end{itemize}

\noindent RemoveWhitespace($line$, $preserveSpecialWhitespace$):
\begin{itemize}
	\item output: $out := conditionedLine$ where:
	\begin{itemize}
		\item If $preserveSpecialWhitespace = TRUE$, $conditionedLine = line$ 
		with white space characters removed except for carriage return 
		(\texttt{\textbackslash r}), line feed (\texttt{\textbackslash n}), and 
		horizontal tab (\texttt{\textbackslash t}) 
		characters
		\item If $preserveSpecialWhitespace = FALSE$, $conditionedLine = line$ 
		with all white space characters removed
	\end{itemize}
	\item exception: N/A
\end{itemize}

\noindent GetLineDelimiter():
\begin{itemize}
	\item output: $out := lineDelimiter$
	\item exception: N/A
\end{itemize}

\noindent GetFieldDelimiter():
\begin{itemize}
	\item output: $out := fieldDelimiter$
	\item exception: N/A
\end{itemize}

\noindent GetValidFileTypes():
\begin{itemize}
	\item output: $out := validFileTypes$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Interval Conversion Module} 
\label{Module_intervalconversion}
The Interval Conversion module transforms a list of interval data and converts 
it into a sequence of Interval Data Structures 
(Section~\ref{Module_intervaldatastructure}). This intermediate step is 
required so that no modules cannot directly access the conversion process and 
must go through the Variable Consolidation 
(Section~\ref{Module_variableconsolidation}) module instead. This design also 
ensures that any changes to the input data format or the conversion process 
will only affect the Variable Consolidation module.

\subsection{Module}

IntervalConversion

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.3cm} p{2cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{8}{3cm}{ConvertToIntervals} & \multirow{8}{2.3cm}{$String^3$} 
		& \multirow{8}{3cm}{$IntervalStruct^n$} & IVC\_CONV\_ERR\_MAX, \\
		& & & IVC\_CONV\_ERR\_MIN, \\
		& & & IVC\_EMPTY\_VARNAME, \\
		& & & IVC\_MISSING\_FIELDS, \\
		& & & IVC\_NO\_BOUNDS, \\
		& & & IVC\_NO\_MAX, \\
		& & & IVC\_NO\_MIN, \\
		& & & IVC\_TOO\_MANY\_FIELDS \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item Ensuring that $min \leq max$ is handled by the IntervalStruct 
	(Section~\ref{Module_intervaldatastructure}) module.
\end{itemize}

\newpage
\subsubsection{Access Routine Semantics}

\noindent ConvertToIntervals($varList, lineDelimiter, fieldDelimiter$):
\begin{itemize}
	\item output: $out := intervals$ where $intervals$ is a sequence of 
	$IntervalStruct$. First, the input $varList$ is converted into an temporary 
	sequence of strings ($tempSeq$). Then, each element in the $intervals$ 
	sequence is created by taking one of the strings from the temporary 
	sequence and creating an $IntervalStruct$ from its fields, where fields are 
	separated by $fieldDelimiter$.
	\item exception: $exc := \\
	(ToReal(max) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MAX)\\
	|\\
	(ToReal(min) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MIN)\\
	|\\
	(varName = ``" \Rightarrow IVC\_EMPTY\_VARNAME)\\
	|\\
	(\exists l \in tempSeq | l.numFields < 3 \Rightarrow IVC\_MISSING\_FIELDS)\\
	|\\
	(min = max = ``" \Rightarrow IVC\_NO\_BOUNDS)\\
	|\\
	(min \neq ``" \wedge max = ``" \Rightarrow IVC\_NO\_MAX)\\
	|\\
	(min = ``" \wedge max \neq ``" \Rightarrow IVC\_NO\_MIN)\\
	|\\
	(\exists l \in tempSeq | l.numFields > 3 \Rightarrow 
	IVC\_TOO\_MANY\_FIELDS)$
\end{itemize}

\newpage

\section{MIS of the Equation Conversion Module} 
\label{Module_equationconversion}
The Equation Conversion module creates an equation tree given an equation 
string using the Precedence Climbing algorithm from:
\begin{center}
	\href{https://www.engr.mun.ca/~theo/Misc/exp\_parsing.htm\#climbing}{https://www.engr.mun.ca/~theo/Misc/exp\_parsing.htm\#climbing}
\end{center}

\subsection{Module}

EquationConversion

\subsection{Uses}

EquationStruct (Section~\ref{Module_equationdatastructure}), OperatorStruct (Section~\ref{Module_operatordatastructure})

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $VARTOKEN : String$
	\item $CONSTTOKEN : String$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.2cm} p{2.8cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{3}{3.2cm}{ConfigureParser} & 
		\multirow{3}{2.8cm}{$OperatorStruct^n$, $String^{n\text{x}2}$} & 
		\multirow{3}{3cm}{$Boolean$} & EQC\_INVALID\_OP, EQC\_NO\_OPS,  
		EQC\_UNBALANCED\_TERMINATOR\\
		ResetEquationConversion & - & - & - \\
		\multirow{4}{3.2cm}{MakeEquationTree} & \multirow{4}{2.8cm}{$String$} & 
		\multirow{4}{3cm}{$EquationStruct$} & EQC\_CONST\_FUNC, \\
		& & & EQC\_IMPLICIT\_MULT, \\
		& & & EQC\_INCOMPLETE\_EQ, \\
		& & & EQC\_INCOMPLETE\_OP \\
		& & & EQC\_UNEXPECTED\_TOKEN, \\
		IsReady & - & $Boolean$ & - \\
		GetVariableList & - & $String^n$ & - \\
		GetVariableToken & - & $String$ & - \\
		GetConstToken & - & $String$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $ready$ : $Boolean$
	\item $variableList$ : $String^n$
	\item $variableStringPattern$ : $String$
	\item $implicitMultiplicationPattern$ : $String$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The ConfigureParser function will always be called before any other 
	function in this module.
	\item The MakeEquationTree function will always be called before the 
	GetVariableList function, otherwise it will not contain any data.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent ConfigureParser($ops, terminators$):
\begin{itemize}
	\item transition: The value of $variableStringPattern$ and 
	$implicitMultiplicationPattern$ are updated so that operators and 
	terminators are not matched when the module is searching for variables. The 
	symbols from $ops$ are used to update both state variables whereas the 
	symbols from $terminators$ are only used to update $variableStringPattern$.
	The state variable $ready$ is updated with the output of this access 
	program.
	\item output: $out := success$ where $success$ is $TRUE$ if no exceptions 
	were encountered and $FALSE$ otherwise.
	\item exception: $exc := \\
	(\exists op \in operators | op.IsUnary == False \wedge op.IsBinary == False 
	\Rightarrow EQC\_INVALID\_OP)\\
	|\\
	(operators = \emptyset \Rightarrow EQC\_NO\_OPS)\\
	|\\
	(\exists t[i][2] \in terminators | t[i][2] == "" \Rightarrow 
	EQC\_UNBALANCED\_TERMINATOR)$
\end{itemize}

\noindent ResetEquationConversion():
\begin{itemize}
	\item transition: All state variables are reset to their default values.
	\item exception: N/A
\end{itemize}

\noindent MakeEquationTree($equationIn$):
\begin{itemize}
	\item transition: The value of $variableList$ is updated with new variable 
	names as they are encountered during equation processing.
	\item output: $out := equationTreeRoot$ where $equationTreeRoot$ is the 
	equation tree produced by the precedence climbing algorithm. This algorithm 
	uses a helper program $Expect(token)$, which raises an exception if the 
	value of $token$ does not match the next character in $equationIn$. 
	Variables in $equationIn$ are recognized using the $variableStringPattern$ 
	state variable.\\
	Before the algorithm executes, $equationIn$ is conditioned to expand 
	implicit multiplication with an explicit multiplication symbol using 
	$implicitMultiplicationPattern$.
	\item exception: $exc := \\
	(ToReal(equationIn) \in \mathbb{R} \Rightarrow EQC\_CONST\_FUNC)\\
	|\\
	(\neg (equationIn.Expand(implicitMultiplicationPattern) = equationIn)\\ 
	\Rightarrow EQC\_IMPLICIT\_MULT)\\
	|\\
	(\neg (MakeEquationTree.Finish \wedge equationIn = "") \Rightarrow 
	EQC\_INCOMPLETE\_EQ)\\
	|\\
	(\exists op \in equationIn | (NULL<op>userEquation) \vee 
	(userEquation<op>NULL) \Rightarrow EQC\_INCOMPLETE\_OP)\\
	|\\
	(\neg Expect(token) = token) \Rightarrow EQC\_UNEXPECTED\_TOKEN)$
\end{itemize}

\noindent IsReady():
\begin{itemize}
	\item output: $out := ready$
	\item exception: N/A
\end{itemize}

\noindent GetVariableToken():
\begin{itemize}
	\item output: $out := VARTOKEN$
	\item exception: N/A
\end{itemize}

\noindent GetConstToken():
\begin{itemize}
	\item output: $out := CONSTTOKEN$
	\item exception: N/A
\end{itemize}

\noindent GetVariableList():
\begin{itemize}
	\item output: $out := variableList$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Variable Consolidation Module} 
\label{Module_variableconsolidation}
The Variable Consolidation module is responsible for coordinating the 
conversion process from input values to Equation and Interval Data Structures. 
This module is intended to be the public interface of the conversion process, 
and the individual conversion modules should not be accessed directly. This 
reduces the amount of maintenance required if either the conversion process 
changes, the format of the inputs change, or any processes that use the results 
of the conversion process.

\subsection{Module}

Consolidate

\subsection{Uses}

IntervalConversion (Section~\ref{Module_intervalconversion}), 
EquationConversion (Section~\ref{Module_equationconversion}), IntervalStruct 
(Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure}), OperatorStruct 
(Section~\ref{Module_operatordatastructure})


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{5.3cm} p{3cm} p{3cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Initialize & - & $Boolean$ & - \\
		\multirow{4}{4.3cm}{ConvertAndCheckInputs} & 
		$String$, $String^n$, $OperatorStruct^n$, 
		$String^{n \times 2}$, $String^2$ & 
		\multirow{4}{3cm}{$Int$} & 
		\multirow{4}{2.3cm}{VC\_INIT\_FAILED, VC\_EXTRA\_VARS, 
		VC\_MISSING\_VARS}\\
		ExtractVariablesFromEquation & $String$ & $String^n$ & - \\
		GetEquationStruct & - & $EquationStruct$ & - \\
		GetIntervalStructList & - & $IntervalStruct^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $equationTreeRoot$ : $EquationStruct$
	\item $intervalList$ : $IntervalStruct^n$
\end{itemize}

\newpage
\subsubsection{Access Routine Semantics}

\noindent Initialize():
\begin{itemize}
	\item output: $out := success$ where $success$ is the value returned from 
	the ConfigureParser access program from EquationConversion. 
	\item exception: N/A
\end{itemize}

\noindent ConvertAndCheckInputs($eqString$, $varList$, $operators$, 
$terminators$, $lineDelimiter$, $fieldDelimiter$):
\begin{itemize}
	\item output: $out := successCode$ where $successCode$ can be:
	\begin{itemize}
		\item 0, if the process completed normally
		\item -1, if the ConfigureParser access program from the 
		EquationConversion module failed (The IsReady access program returns 
		$FALSE$)
		\item -2, if there are variables in the equation that are not defined 
		in the variable list
		\item -3, if the MakeEquationTree access program from the 
		EquationConversion module returned a \texttt{NULL} value
	\end{itemize}
	\item transition: 
	\begin{itemize}
		\item The parameters $operators$ and $terminators$ are passed as inputs 
		to the ConfigureParser access program from the Equation Conversion 
		module.
		\item The state variable $equationTreeRoot$ is assigned the output 
		from the MakeEquationTree access program from the Equation Conversion 
		module with the input parameter $eqString$.
		\item The state variable $intervalList$ is assigned the output from the 
		ConvertToIntervals access program from the Interval Conversion module 
		with the input parameters $varList$, $lineDelimiter$, and 
		$fieldDelimiter$.
		\item The outputs from the GetVariableList access program from the 
		Equation Conversion module and the GetVariableNamesFromIntervals access 
		program with the input parameter $intervalList$ are compared to ensure 
		that enough variable definitions exist in $intervalList$ to match the 
		existing variables in $equationTreeRoot$.
	\end{itemize}
	\item exception: $exc := \\
	(EquationConversion.IsReady == FALSE \Rightarrow VC\_INIT\_FAILED)\\
	|\\
	(\exists var | var \notin eqString \wedge var \in varList \Rightarrow 
	VC\_EXTRA\_VARS)\\
	|\\
	(\exists var | var \in eqString \wedge var \notin varList \Rightarrow 
	VC\_MISSING\_VARS)$
\end{itemize}

\noindent ExtractVariablesFromEquation($equation$):
\begin{itemize}
	\item output: $out := varList$ where $varList$ is the output of the 
	GetVariableList access program after the MakeEquationTree access program 
	has been called. Both access programs are from the EquationConversion 
	module.
	\item exception: N/A
\end{itemize}

\noindent GetEquationStruct():
\begin{itemize}
	\item output: $out := equationTreeRoot$
	\item exception: N/A
\end{itemize}

\noindent GetIntervalStructList():
\begin{itemize}
	\item output: $out := intervalList$ 
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Range Solver Module} 
\label{Module_rangesolver}
The Range Solver module contains the logic required to perform interval 
arithmetic operations.

\subsection{Module}

Solver

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure}), OperatorStruct (Section~\ref{Module_operatordatastructure})

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $supportedOps : operatorStruct^n$
	\item $supportedTerminators : String^{n\text{x}2}$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.5cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		GetValidOperators & - & $OperatorStruct^n$ & -\\
		GetValidTerminators & - & $String^{n\text{x}2}$ & -\\
		\multirow{4}{3.1cm}{FindRange} & \multirow{4}{3cm}{$EquationStruct$, 
		$IntervalStruct^n$} & \multirow{4}{3cm}{$IntervalStruct$} & 
		SOL\_MISSING\_VAR, \\
		& & & SOL\_NO\_EQ, \\
		& & & SOL\_REAL\_EXPONENT, \\
		& & & SOL\_UNSUPPORTED\_OP \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item The structure of $EquationStruct$ is based on operator precedence.
	\item The type of $IntervalStruct^n$ accepts \texttt{NULL} as a valid 
	value. This supports the computation of constant value equations.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent GetValidOperators():
\begin{itemize}
	\item output: $out := supportedOps$
	\item exception: N/A
\end{itemize}

\noindent GetValidTerminators():
\begin{itemize}
	\item output: $out := supportedTerminators$
	\item exception: N/A
\end{itemize}

\noindent FindRange($eqRoot, intervals$):
\begin{itemize}
	\item output: $out := range$ where $range$ is the result of performing and 
	composing interval arithmetic operations on $eqRoot$ using the intervals 
	from $intervals$. The cases are:
	\begin{itemize}
		\item If $eqRoot$ is a variable, then range is the interval from 
		$intervals$ with that variable name ($varName$)
		\item If $eqRoot$ is a constant, then the range is an interval with 
		both bounds set to the constant value
		\item If $eqRoot$ is an operator node, then the range is:\\
		FindRange($eqRoot.LeftOperand$)$<eqRoot.Operator>$FindRange($eqRoot.RightOperand$)
	\end{itemize}
	
	
	\item exception: $exc := \\
	(\exists varName \in eqRoot \wedge varName \notin intervals \Rightarrow 
	SOL\_MISSING\_VAR)\\
	|\\
	(eqRoot = NULL \Rightarrow SOL\_NO\_EQ)\\
	|\\
	(\exists op \in eqRoot \wedge op = x^n \wedge n \notin \mathbb{N} 
	\Rightarrow SOL\_REAL\_EXPONENT) \\
	|\\
	((\exists op \in eqRoot \wedge op \notin supportedOps) \\
	\vee (\exists iv1, iv2 \in intervals \wedge \nexists op \in supportedOps 
	| op(iv1, iv2) \vee op(iv2, iv1)) \\
	\Rightarrow SOL\_UNSUPPORTED\_OP)$ 
\end{itemize}

\newpage

\section{MIS of the Output Module} 
\label{Module_output}
The Output module is responsible for converting data structures into 
output-friendly formats.

\subsection{Module}

Output

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.1cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{2}{3.1cm}{PrintInterval} & $IntervalStruct$, $Boolean$ & 
		\multirow{2}{3cm}{$String$} & \multirow{2}{5cm}{-} \\
		PrintEquationTree & $equationStruct$ & $String$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no exceptions in this module because it is assumed that 
	only well-formed inputs will be passed in. This assumption is made knowing 
	that this module will only be called post-process and any errors in the 
	data structures have already been identified.
	\item The object passed to PrintEquationTree is the root of the equation 
	tree.
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent PrintInterval($interval, withVarName$):
\begin{itemize}
	\item output: $out := formattedInterval$ where $formattedInterval$ is a 
	string corresponding the fields in $interval$:
	\begin{itemize}
		\item If $interval$ is a constant value, $formattedInterval$ is 
		$CONST:$ with the value appended
		\item Otherwise:
		\begin{itemize}
			\item If $withVarName$ is true, the $formattedInterval$ begins with 
			the interval's variable name and `` = "
			\item If $interval$ is closed on the left boundary, append ``$[$" 
			to $formattedInterval$; otherwise, append ``$($"
			\item Append the minimum and maximum boundary values from 
			$interval$ 
			separated by a comma (``,"); if the minimum bound has more that 12 
			values, put the maximum boundary value on a new line
			\item If $interval$ is closed on the right boundary, append $]$ to 
			$formattedInterval$; otherwise, append $)$
		\end{itemize}
	\end{itemize}
	\item exception: N/A
\end{itemize}

\noindent PrintEquationTree($eqRoot$):
\begin{itemize}
	\item output: $out := formattedTree$ where $formattedTree$ is a 
	string corresponding the formatted $eqRoot$:
	\begin{itemize}
		\item If $eqRoot$ is a variable, append $+- \{VAR\}$ and the variable 
		name
		\item If $eqRoot$ is a constant, append $+- \{CONST\}$ and the value
		\item If $eqRoot$ is an operator node, append $+- \{<op>\}$ where $op$ 
		is 
		the node operator:
		\item If $eqRoot$ is a right operand and has no left of right 
		operands of its own, append ``   "; this will align the tree levels
		\item If $eqRoot$ is not a right operator or has a left or right 
		operand, append ``\textbar ";  this will align the tree levels
		\item Append a new line character and print the trees corresponding 
		to the left and right operands of $eqRoot$ if they exist
	\end{itemize}
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Interval Data Structure Module} 
\label{Module_intervaldatastructure}
The Interval Data Structure represents a mathematical interval with end points 
$minBound$ and $maxBound$. This implementation is designed to be application 
dependant.

\subsection{Module}

IntervalStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.8cm} p{2.5cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline		
		IntervalStruct & $String$, $\mathbb{R}^2$, $Boolean^2$ & 
		$IntervalStruct$ & 
		IV\_ORD\_VIOLATED \\
		GetVariableName & - & $String$ & - \\
		GetMinBound & - & $\mathbb{R}$ & - \\
		GetMaxBound & - & $\mathbb{R}$ & - \\
		IsLeftBoundClosed & - & $Boolean$ & - \\
		IsRightBoundClosed & - & $Boolean$ & - \\
		SetVariableName & $String$ & - & - \\
		SetMinBound & $\mathbb{R}$ & - & IV\_MIN\_ORD\_VIOLATED \\
		SetMaxBound & $\mathbb{R}$ & - & IV\_MAX\_ORD\_VIOLATED \\
		SetLeftBoundClosed & $Boolean$ & - & - \\
		SetRightBoundClosed & $Boolean$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# For \rref{R_conditionX} using \ddref{DD_interval}
\begin{itemize}
	\item $variableName$ : $String$
	\item $minBound : \mathbb{R}$
	\item $maxBound : \mathbb{R}$
	\item $isClosedLeft : Boolean$
	\item $isClosedRight : Boolean$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent IntervalStruct($varName, minB, maxB, leftClosed, RightClosed$):
\begin{itemize}
	\item output: $out := new IntervalStruct(variableName$, $minBound$, 
	$maxBound$, $isClosedLeft$, $isClosedRight)$
	\item transition: Update state variables $variableName$, $minBound$, 
	$maxBound$, $isClosedLeft$, and $isClosedRight$ with the provided values 
	$varName$, $minB$, $maxB$, $leftClosed$, and $rightClosed$
	\item exception: $exc := \\
	(minB > maxB \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\noindent GetVariableName():
\begin{itemize}
	\item output: $out := variableName$
	\item exception: N/A
\end{itemize}

\noindent GetMinBound():
\begin{itemize}
	\item output: $out := minBound$
	\item exception: N/A
\end{itemize}

\noindent GetMaxBound():
\begin{itemize}
	\item output: $out := maxBound$
	\item exception: N/A
\end{itemize}

\noindent IsLeftBoundClosed():
\begin{itemize}
	\item output: $out := isClosedLeft$
	\item exception: N/A
\end{itemize}

\noindent IsRightBoundClosed():
\begin{itemize}
	\item output: $out := isClosedRight$
	\item exception: N/A
\end{itemize}

\noindent SetVariableName($varName$):
\begin{itemize}
	\item transition: Update state variable $variableName$ with the provided 
	value $varName$
	\item exception: N/A
\end{itemize}

\noindent SetMinBound($minB$):
\begin{itemize}
	\item transition: Update state variable $minBound$ with the provided value 
	$minB$
	\item exception: $exc := \\
	(minB > maxBound \Rightarrow IV\_MIN\_ORD\_VIOLATED)$
\end{itemize}

\noindent SetMaxBound($maxB$):
\begin{itemize}
	\item transition: Update state variable $maxBound$ with the provided value 
	$maxB$
	\item exception: $exc := \\
	(maxB < minBound \Rightarrow IV\_MAX\_ORD\_VIOLATED)$
\end{itemize}

\noindent SetLeftBoundClosed($closed$):
\begin{itemize}
	\item transition: Update state variable $isClosedLeft$ with the provided 
	value $closed$
	\item exception: N/A
\end{itemize}

\noindent SetRightBoundClosed($closed$):
\begin{itemize}
	\item transition: Update state variable $isClosedRight$ with the provided 
	value $closed$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Equation Data Structure Module} 
\label{Module_equationdatastructure}
The Equation Data Structure represents a node in an equation tree which can 
support up to two-operand operations. The tree can be expanded by assigning 
other nodes as the left and right operands.

\subsection{Module}

EquationStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{2}{3cm}{EquationStruct} & $String^2$, $EquationStruct^2$ & 
		\multirow{2}{3cm}{$EquationStruct$} & 
		\multirow{2}{5cm}{EQS\_MISSING\_OP}\\
		GetOperator & - & $String$ & - \\
		GetVariableName & - & $String$ & - \\
		GetLeftOperand & - & $EquationStruct$ & -\\
		GetRightOperand & - & $EquationStruct$ & - \\
		SetVariableName & $String$ & - & - \\
		SetLeftOperand & $EquationStruct$ & - & - \\
		SetRightOperand & $EquationStruct$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# To support \rref{R_conditionfx} and \rref{R_CalculateCompose}
\begin{itemize}
	\item $operatr : String$
	\item $variableName : String$
	\item $leftOperand : EquationStruct$
	\item $rightOperand : EquationStruct$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The decomposition of the user equation is handled by the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item Unsupported operators are identified and handled in the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item There is no setter method for the $operator$ field because they will 
	not be changed after initialization.
	\item The values for $leftOperand$ and $rightOperand$ can be set to 
	\texttt{NULL} as required (e.g. variables, constants).
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent EquationStruct($op, vName, eStruct1, eStruct2$):
\begin{itemize}
	\item output: $out := new EquationStruct(operatr$, $variableName$, 
	$leftOperand$, $rightOperand)$
	\item transition: Update state variables $operatr$, $variableName$, 
	$leftOperand$, and $rightOperand$ with the provided values $op$, $vName$, 
	$eStruct1,$ and $eStruct2$
	\item exception: $exc := \\
	(op = ``" \Rightarrow EQS\_MISSING\_OP)$
\end{itemize}

\noindent GetOperator():
\begin{itemize}
	\item output: $out := operatr$
	\item exception: N/A
\end{itemize}

\noindent GetVariableName():
\begin{itemize}
	\item output: $out := variableName$
	\item exception: N/A
\end{itemize}

\noindent GetLeftOperand():
\begin{itemize}
	\item output: $out := leftOperand$
	\item exception: N/A
\end{itemize}

\noindent GetRightOperand():
\begin{itemize}
	\item output: $out := rightOperand$
	\item exception: N/A
\end{itemize}

\noindent SetVariableName($vName$):
\begin{itemize}
	\item transition: Update state variable $variableName$ with the provided 
	value $vName$
	\item exception: N/A
\end{itemize}

\noindent SetLeftOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $leftOperand$ with the provided 
	value $eStruct$
	\item exception: N/A
\end{itemize}

\noindent SetRightOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $rightOperand$ with the provided 
	value $eStruct$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Operator Data Structure Module} 
\label{Module_operatordatastructure}
The Operator Data Structure contains all relevant information required to 
correctly use them in a mathematical context. It is much simpler to pass a 
single data structure containing all of the associated fields for an operator 
as opposed to creating a class with lists of information that must queried and 
returned individually for each associated operator field.

\subsection{Module}

OperatorStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{3cm}{OperatorStruct} & \multirow{4}{3cm}{$String$, $Int$, 
		$Boolean^4$} & \multirow{4}{3cm}{$OperatorStruct$} & 
		OP\_INVALID\_PRECEDENCE, OP\_MISSING\_OP, 
		OP\_MULTI\_TYPE, OP\_NO\_TYPE\\
		GetOperator & - & $String$ & - \\
		GetPrecedence & - & $Int$ & - \\
		IsUnary & - & $Boolean$ & - \\
		IsBinary & - & $Boolean$ & - \\
		IsTernary & - & $Boolean$ & - \\
		IsLeftAssociative & - & $Boolean$ & -\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $operatr : String$
	\item $precedence : Int$
	\item $isUnary : Boolean$
	\item $isBinary : Boolean$
	\item $isTernary : Boolean$
	\item $leftAssociative : Boolean$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no Setter methods for this module because operator properties are fixed.
	\item A high integer value is associated with a high precedence operation.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent OperatorStruct($op, prec, isUnary, isBinary, isTernary, isLeftAssociative$):
\begin{itemize}
	\item output: $out := new OperatorStruct(operatr$, $precedence$, $isUnary$, 
	$isBinary$, $isTernary$, $leftAssociative)$
	\item transition: Update state variables $operatr$, $precedence$, 
	$isUnary$, $isBinary$, $isTernary$, and $leftAssociative$ with the provided 
	values $op$, $prec$, $isUnary$, $isBinary$, $isTernary$, and 
	$isLeftAssociative$.
	\item exception: $exc := \\
	(prec < 0 \Rightarrow OP\_INVALID\_PRECEDENCE)\\
	|\\
	(op = ``" \Rightarrow OP\_MISSING\_OP)\\
	|\\
	((isUnary = isBinary \wedge isUnary = True) \vee (isUnary = isTernary 
	\wedge isUnary = True) \vee (isBinary = isTernary \wedge isBinary = True) 
	\Rightarrow OP\_MULTI\_TYPE)\\
	|\\
	(isUnary = isBinary = isTernary \wedge isUnary = False \Rightarrow 
	OP\_NO\_TYPE)$
\end{itemize}

\noindent GetOperator():
\begin{itemize}
	\item output: $out := operatr$
	\item exception: N/A
\end{itemize}

\noindent GetPrecedence():
\begin{itemize}
	\item output: $out := precedence$
	\item exception: N/A
\end{itemize}

\noindent IsUnary():
\begin{itemize}
	\item output: $out := isUnary$
	\item exception: N/A
\end{itemize}

\noindent IsBinary():
\begin{itemize}
	\item output: $out := isBinary$
	\item exception: N/A
\end{itemize}

\noindent IsTernary():
\begin{itemize}
	\item output: $out := isTernary$
	\item exception: N/A
\end{itemize}

\noindent IsLeftAssociative():
\begin{itemize}
	\item output: $out := leftAssociative$
	\item exception: N/A
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}

\newpage

\section{Appendix} \label{Appendix}

\renewcommand{\arraystretch}{1.2}

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Error Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQC\_INVALID\_OP & Error: The equation conversion module cannot parse the 
	$<token>$ operator. \\ 
	EQC\_NO\_OPS & Error: No operators were passed to the parser. \\ 
	EQC\_UNBALANCED\_TERMINATOR & Error: An unbalanced (left \textbar right) 
	terminator token was encountered ($<token>$).\\
	EQC\_INCOMPLETE\_EQ & Error: Could not find the end of the equation. \\
	EQC\_INCOMPLETE\_OP & Error: Unrecognized sequence encountered during 
	Atomic Equation parsing. Remaining equation = $<remainingEquationString>$.\\
	EQC\_UNEXPECTED\_TOKEN & Error: Could not find expected token $<token>$. \\	
	EQS\_MISSING\_OP & Error: Equation structures must be assigned an operator 
	during initialization. \\
	IN\_CANNOT\_READ\_FILE & Error: The file could not be read. \\	
	IN\_EMPTY\_FILE & Error: The file is empty. \\
	IN\_INVALID\_FILE\_TYPE & Error: Cannot read files of this type. \\
	IN\_NO\_EQUATION & Error: The first line of the file is not an equation or 
	the equation contains $<Input.GetFieldDelimiter>$.\\
	IN\_NO\_FILE & Error: The specified file does not exist. \\ 
	IVC\_CONV\_ERR\_MIN & Error: The string provided for the minimum bound 
	cannot be converted to a real number. \\
	IVC\_CONV\_ERR\_MAX & Error: The string provided for the maximum bound 
	cannot be converted to a real number.\\
	IVC\_EMPTY\_VARNAME & Error: Intervals must have an associated variable 
	name. \\
	IVC\_MISSING\_FIELDS & Error: No fields found for variable (Line 
	$<lineNumber>$). Skipping line.\\
	IVC\_NO\_BOUNDS & Error: No values provided for either interval bound. \\
	IVC\_TOO\_MANY\_FIELDS & Error: Encountered a variable with more than three 
	fields (Line $<lineNumber>$). Skipping line. \\
	OP\_INVALID\_PRECEDENCE & Error: Cannot assign a precedence value less than 
	0.\\
	OP\_MISSING\_OP & Error: Cannot have an operator with no representative 
	symbol. 
	\\
	OP\_MULTI\_TYPE & Error: An operator cannot be overloaded to be unary, 
	binary, and ternary. \\
	OP\_NO\_TYPE & Error: Operators must be assigned a number of operands type. 
	\\
	SOL\_MISSING\_VAR & Error: Could not find an associated interval for 
	variable $<varname>$. \\
	SOL\_NO\_EQ & Error: No information was provided for the equation. \\
	SOL\_UNSUPPORTED\_OP & Error: An unsupported operation was encountered 
	while solving for the range of the equation (Unknown operator \textbar 
	Mixed interval division \textbar Exponents \textbar Exponent base $<= 1$ 
	\textbar Exponent $< 0$).\\
	VC\_INIT\_FAILED & Error: Equation parser could not be configured. \\
	VC\_MISSING\_VARS & Error: Cannot find intervals for variable name(s): 
	$<variable list>$. \\
	\bottomrule
\end{longtable}

\newpage

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Warning Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQC\_CONST\_FUNC & Warning: The user equation is a constant value and the 
	range will only include this value.\\
	EQC\_IMPLICIT\_MULT & Warning: Encountered an implicit multiplication of a 
	constant value and a variable. Expanding with explicit operator. \\
	IV\_MAX\_ORD\_VIOLATED & Warning: Value provided for maximum bound is 
	smaller than the current minimum bound. The values have been exchanged to 
	maintain the interval ordering. \\
	IV\_MIN\_ORD\_VIOLATED & Warning: Value provided for minimum bound is 
	greater than the current maximum bound. The values have been exchanged to 
	maintain the interval ordering. \\
	IV\_ORD\_VIOLATED & Warning: Value provided for intervals are not in 
	increasing order. The values have been exchanged to maintain the interval 
	ordering. \\
	IVC\_NO\_MIN & Warning: No minimum interval bound given. Setting it to the 
	same value as the maximum bound. \\
	IVC\_NO\_MAX & Warning: No maximum interval bound given. Setting it to the 
	same value as the minimum bound. \\
	SOL\_REAL\_EXPONENT & Warning: The value provided for the exponent $<N>$ is 
	not a natural number. It has been rounded to $<Round(N)>$. \\
	VC\_EXTRA\_VARS & Warning: Extraneous variables found in interval list 
	($<variable list>$). \\
	\bottomrule
\end{longtable}

\end{document}